/****************************************************
* 	ParateCompilateur - Parseur											*
* 	Auteur : Florian Kauder													*
* 		librement inspiré par la grammaire C					*
****************************************************/

import java_cup.runtime.*;
import java.util.Vector;
import java.io.*;

parser code {:
	public void syntax_error(Symbol s){
		System.out.println("[ERROR][SYNTAX] Ligne : " + s.left + " - Colonne : " + s.right);
	}
:}

terminal LPAR, RPAR, SEMIC, PLUS, MULT, LACC, RACC, INC_OP, DEC_OP, AND, MOINS, TILDE, NE, DIV, MOD,
	 LEFT_OP, RIGHT_OP, LEFT, RIGHT, LE_OP, GE_OP, EQ_OP, NE_OP, XOR, OR, AND_OP, OR_OP, EQ,
	 MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN, LEFT_ASSIGN, RIGHT_ASSIGN,
	 AND_ASSIGN, XOR_ASSIGN, OR_ASSIGN, COLON, COMMA, SINGLEQUOTE, QUOTE, MINUS,
	 RBRA, LBRA, POINT, ARROW;

terminal INTEGER, CHARACTER, FLOAT, BOOLEAN, STRING;
terminal FALSE, TRUE, NULL;
terminal FOREACH, REPEAT, STOP, FUNCTION;
terminal LISTOF, STRUCTURE, CLASS, TYPE, PROCEDURE, PUBLIC, PRIVATE;
terminal ID, INT, IN;
terminal NB, NBV;

terminal IF, AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE, ELSE, ENUM, EXTERN,
	 FOR, GOTO, LONG, REGISTER, RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH,
	 TYPEDEF, UNION, UNSIGNED, VOID, VOLATILE, WHILE;


/* The grammar */
non terminal program, program_elements;
non terminal function_parameters, function_declaration, parameters_list;
non terminal statement, compound_statement, expression_statement, end_statement,
	if_statement, loop_statement;
non terminal expression, postfix_expression, primary_expression, unary_expression,
	unary_operator, multiplicative_expression, shift_expression, assignment_operator,
	additive_expression, relational_expression, and_expression,
	equality_expression, exclusive_or_expression, inclusive_or_expression, logical_and_expression,
	logical_or_expression, assignment_expression, constant_value, array_of_elements, elements;
non terminal block_item, block_item_list;
non terminal var_declaration, var_and_type, var_declaration_list, var_list;
non terminal type_declaration;
non terminal type, type_simple, type_complex;
non terminal class_content, class_list, class_declaration, class_function_declaration,
	class_var_declaration;

precedence left ELSE;
precedence left IF, SEMIC;

start with program;

program ::=
		program_elements
		;

program_elements ::=
		function_declaration
		| class_declaration
		| program_elements function_declaration
		| program_elements class_declaration
		;

/** Déclaration des fonctions */

function_declaration ::=
		PROCEDURE ID:fName function_parameters compound_statement
		{: System.out.println("Procédure \"" + fName + "\" correcte"); :}
		| PROCEDURE ID:fName function_parameters SEMIC
		{: System.out.println("Procédure \"" + fName + "\" déclarée"); :}
		| FUNCTION ID:fName function_parameters compound_statement
		{: System.out.println("Fonction \"" + fName + "\" correcte"); :}
		| FUNCTION ID:fName function_parameters SEMIC
		{: System.out.println("Fonction \"" + fName + "\" déclarée"); :}
		| error {: System.out.println("[ERROR][SYNTAX] Erreur dans la fonction"); :}
		;

function_parameters ::=
		LPAR RPAR
		| LPAR parameters_list RPAR
		;

parameters_list ::=
		var_and_type
		| parameters_list COMMA var_and_type
		;

/* Blocs */

compound_statement ::=
		LACC RACC
		| LACC block_item_list RACC
		;

block_item_list ::=
		block_item
		| block_item_list block_item
		;

block_item ::=
		var_declaration
		| type_declaration
		| statement
		;

/** Instructions */

statement ::=
		compound_statement
		| expression_statement
		| if_statement
		| loop_statement
		| end_statement
		;

/** Boucles */

loop_statement ::=
		FOREACH ID IN primary_expression statement
		| WHILE LPAR expression RPAR statement
		| REPEAT statement WHILE LPAR expression RPAR
		;

/** Instruction Si */

if_statement ::=
		IF LPAR expression RPAR statement
		| IF LPAR expression RPAR statement ELSE statement
		;

/** Instructions de fin */

end_statement ::=
		RETURN expression SEMIC
		| STOP SEMIC
		| BREAK SEMIC
		;

/** Expressions */

expression_statement ::=
		SEMIC
		| expression SEMIC
		| error SEMIC {: System.out.println("[ERROR][SYNTAX] Erreur dans l'expression"); :}
		;

expression ::=
 		assignment_expression
		| expression COMMA assignment_expression
		;

postfix_expression ::=
		primary_expression
		| postfix_expression LBRA expression RBRA
		| postfix_expression LPAR RPAR
		| postfix_expression LPAR expression RPAR
		| postfix_expression POINT ID
		| postfix_expression ARROW ID
		| postfix_expression INC_OP
		| postfix_expression DEC_OP
		;

constant_value ::=
		TRUE
		| FALSE
		| NULL
		;

array_of_elements ::=
		LBRA elements RBRA
		;

elements ::=
		primary_expression
		| elements COMMA primary_expression
		| error {: System.out.println("[ERROR][SYNTAX] Erreur de syntaxe dans le tableau"); :}
		;

primary_expression ::=
		ID
		| NB
		| NBV
		| STRING
		| constant_value
		| array_of_elements
		| LPAR expression RPAR
		;

unary_expression ::=
		postfix_expression
		| INC_OP unary_expression
		| DEC_OP unary_expression
		| unary_operator unary_expression
		;

unary_operator ::=
		AND
		| MULT
		| PLUS
		| MINUS
		| TILDE
		| NE
		;

multiplicative_expression ::=
		unary_expression
		| multiplicative_expression MULT unary_expression
		| multiplicative_expression DIV unary_expression
		| multiplicative_expression MOD unary_expression
		;

additive_expression ::=
		multiplicative_expression
		| additive_expression PLUS multiplicative_expression
		| additive_expression MINUS multiplicative_expression
		;

shift_expression ::=
		additive_expression
		| shift_expression LEFT_OP additive_expression
		| shift_expression RIGHT_OP additive_expression
		;

relational_expression ::=
		shift_expression
		| relational_expression LEFT shift_expression
		| relational_expression RIGHT shift_expression
		| relational_expression LE_OP shift_expression
		| relational_expression GE_OP shift_expression
		;

equality_expression ::=
		relational_expression
		| equality_expression EQ_OP relational_expression
		| equality_expression NE_OP relational_expression
		;

and_expression ::=
		equality_expression
		| and_expression AND equality_expression
		;

exclusive_or_expression ::=
		and_expression
		| exclusive_or_expression XOR and_expression
		;

inclusive_or_expression ::=
		exclusive_or_expression
		| inclusive_or_expression OR exclusive_or_expression
		;

logical_and_expression ::=
		inclusive_or_expression
		| logical_and_expression AND_OP inclusive_or_expression
		;

logical_or_expression ::=
		logical_and_expression
		| logical_or_expression OR_OP logical_and_expression
		;

assignment_expression ::=
		logical_or_expression
		| unary_expression assignment_operator assignment_expression
		;

assignment_operator ::=
  	EQ
		| MUL_ASSIGN
		| DIV_ASSIGN
		| MOD_ASSIGN
		| ADD_ASSIGN
		| SUB_ASSIGN
		| LEFT_ASSIGN
		| RIGHT_ASSIGN
		| AND_ASSIGN
		| XOR_ASSIGN
		| OR_ASSIGN
		| error {: System.out.println("[ERROR][SYNTAX] Opérateur d'assignement inconnu"); :}
		;

/** Declaration des variables */

var_declaration ::=
		var_and_type SEMIC
		;

var_and_type ::=
		ID COLON type
		;

var_declaration_list ::=
		var_declaration
		| var_declaration_list var_declaration
		;

/** Declaration de types */

type_declaration ::=
		TYPE ID EQ type SEMIC
		| error {: System.out.println("[ERROR][SYNTAX] Erreur dans la déclaration de type"); :}
		;

/** Types simples et complexes */

type ::=
		type_simple
		| type_complex
		| error {: System.out.println("[ERROR][SYNTAX] Type inconnu"); :}
		;

type_simple ::=
		INT
		| CHARACTER
		| FLOAT
		|	BOOLEAN
		| STRING
		| SINGLEQUOTE ID
		;

type_complex ::=
		LISTOF type
		| XOR type
		| STRUCTURE LACC var_declaration_list RACC
		| CLASS LACC class_content RACC
		;

/** Classes */

class_declaration ::=
		CLASS ID:cName LACC class_content RACC
		{: System.out.println("Classe \"" + cName + "\" correcte"); :}
		;

class_content ::=
		class_var_declaration
		| class_function_declaration
		| class_content class_function_declaration
		| class_content class_var_declaration
		;

class_var_declaration ::=
		ID COLON type SEMIC
		| STATIC ID COLON type SEMIC
		| PRIVATE ID COLON type SEMIC
		| PRIVATE STATIC ID COLON type SEMIC
		;

class_function_declaration ::=
		ID function_parameters compound_statement
		{: System.out.println("Constructeur correct"); :}
		| TILDE ID function_parameters compound_statement
		{: System.out.println("Destructeur correct"); :}
		| FUNCTION ID:fName function_parameters COLON type compound_statement
		{: System.out.println("Fonction \"" + fName + "\" correcte"); :}
		;
